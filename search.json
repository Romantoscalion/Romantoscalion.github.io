[{"title":"Unity切线空间及其应用","date":"2025-01-22T08:20:07.000Z","url":"/2025/01/22/Unity%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","tags":[["长篇","/tags/%E9%95%BF%E7%AF%87/"],["渲染","/tags/%E6%B8%B2%E6%9F%93/"],["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"],["图形学","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Unity","/categories/Unity/"]],"content":" Object空间是每个Mesh独有的、在建模阶段就已经确定的空间；Vertex的顶点位置、法线方向等信息都记录在Object空间中。 切线空间是每个Vertex独有的、由Vertex的切线、副切线和法线分别作为XYZ坐标轴、以Vertex在Object空间下的位置作为Pivot组成的空间。切线空间会跟随Mesh的变形（Skinned Mesh等）而改变，这是因为Mesh变形时，Vertex的法线、切线和副切线也会随之变换。 切线的确定方式模型文件导入Unity后会生成Mesh资产，Vertex的法线直接从模型文件中读取，而切线会根据Vertex的UV重新计算。 在Unity Mesh中，Vertex的切线方向是一个与其法线垂直的、指向uv中U维增大方向的向量。 下面这张GIF中，蓝线代表Vertex的法线，黄线代表Vertex的切线。可以观察到，当UV开始旋转时，Vertex的切线方向也随之旋转，它始终指向UV中U维增大的方向。 副切线的确定方式副切线是同时垂直于法线和切线的向量，存在两个这样的方向。 参考这篇文章可以得知：副切线的选择由切线向量的w维（建模时确定）及RendererTransform的Scale同时确定。 切线空间的变换矩阵从Mesh中可以获取Vertex在Object空间中的位置、切线、副切线和法线的方向，可以来构建TangentToObject矩阵了。 根据我们学过的线性代数知识，要构建一个LocalToWorld的变换矩阵，需要将4X4矩阵的第一列设置为X轴的方向向量、第二列设置为Y轴的方向向量、第三列设置为Z轴的方向向量、第四列设置为Translate、矩阵的第四行设置为（0,0,0,1）。 TangentToObject变换是一种LocalToWorld变换，因此它们的步骤也是一致的。在Unity中，我们约定切线空间的X轴为切线方向（右），Y轴方向为副切线方向（上）， Z轴方向为法线方向（前），可以用下面的代码来构建TangentToObject矩阵： ※：使用Mesh.GetNormals()等方法获取到的Mesh的法线、切线和副切线方向是已经经过归一化的，不需要额外处理。另外，在ShaderGraph中直接通过Normal Vector等节点获取到的法线、切线和副切线方向也是经过归一化的，也不需要再额外处理。 切线空间的应用思路切线空间的应用思路一般是：将Object空间信息在制作阶段转为Tangent空间信息（特殊的位置、方向等），保存到Vertex的数据位或者贴图中；在Shader中，将读取到的Tangent空间信息重新转回Object空间使用。 你可能会好奇，为什么要这么倒腾一下呢？这是因为切线空间有一个重要的非常好的性质，那就是在文章开头提到过的：切线空间会跟随Mesh的变形发生改变（这是因为Vertex的法线和切线都会随着Mesh的变形发生改变），因此当Shader把切线空间中的特殊数据转回Object空间时，这份特殊数据也会接受到Mesh的变形。 从下面的GIF中，我们可以清晰地观察到切线空间的变化： 切线空间最广泛的应用是法线贴图，一般来说法线贴图中储存的就是切线空间中对法线方向的扰动。 我们来通过一个例子来看下如果将法线方向扰动储存在Object空间中会导致什么样的结果： 如果按照常规将法线偏移信息储存在切线空间中，变形后的物体法线方向正确： ※：这也能引申出法线贴图总是呈现蓝紫色的原因，物体的表面大部分区域扰动并不强烈，即“扰动方向和几何图元法线的夹角很小”，表现在偏移方向向量上就是：（x方向-切线方向-小值，y方向-副切线方向-小值，z方向-几何图元法线方向-大值），几乎（0,0,1）的状态；又因为单位向量每维度的取值范围是-1~1，因此需要做一步remap(-1,1,0,1,x);，就变成了（0.5,0.5,1），将其转换为颜色就是法线贴图中常见的蓝紫色。"},{"title":"Mesh顶点的连接性","date":"2025-01-22T08:18:51.000Z","url":"/2025/01/22/Mesh%E9%A1%B6%E7%82%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%80%A7/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["C#","/tags/C/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["Unity","/categories/Unity/"]],"content":"盘问GPT榨出来的代码，测过了，非常好用。 输入一个Mesh，返回一个和Vertices等长的Int列表，代表Vertex属于Mesh中各分离的Parts的哪一块。 "},{"title":"C# Enumerable Aggregate","date":"2025-01-22T08:17:29.000Z","url":"/2025/01/22/CSharp%20Enumerable%20Aggregate/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["C#","/tags/C/"]],"categories":[["Unity","/categories/Unity/"]],"content":"之前都没注意到有这么好用的东西，这个东西的大体思路是对于一个Enumerable的对象，以列表为例，传一个任意类型的初始的随意什么东西进去，然后遍历列表中的每一对象，对这个初始的东西做累计的任意操作，遍历完后还可以进行一次转换，返回遍历完的这个初始对象。 这么做可以减少一些for循环，增不增加可读性不知道，但是代码看着会简洁不少。 下面列一些微软给的示例代码： 有两个Aggregate的参数少一些的重载，比如下面这个是省去了输出时的转换方法： 初始值也可以省掉，不过需要注意，如果省掉初始值，会以列表中的第0项作为初始值开始遍历，而且遍历会跳过第0项。 "},{"title":"C# delegate event 和 事件系统","date":"2025-01-16T03:50:36.000Z","url":"/2025/01/16/CSharp%20delegate%20event%20%E5%92%8C%20%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/","tags":[["C#","/tags/C/"],["长篇","/tags/%E9%95%BF%E7%AF%87/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"categories":[["Unity","/categories/Unity/"]],"content":"游戏开发中常用事件模式的设计思路；以Unity为例，借助C#的特性可以轻松地实现事件系统。 delegate 委托通俗地说，委托就是一个占坑用的方法，这个方法会在开发者指定的时刻被调用，至于方法的内容是什么，就看代码逻辑中给委托里订阅了什么内容了。 举例来说，现在有一个按钮，它有一个委托“OnPressed”，在用户按下去的时候会执行这个委托；具体会发生什么呢？这就看游戏中的其他模块往这个委托中添加了什么方法了。 这么做可以大大提升程序的灵活性、可重用性，也将不同模块的耦合度降低了， delegate 是C#中的一个关键字，用于标记这条语句正在声明一个委托类型，这一点与关键字enum类似。 上示的代码声明了一个名为Callback的委托类型，注意这里同时声明了返回类型void和方法的参数。下文将以Callback类为例展开说明。 Callback类的对象是**“方法”，Callback类的对象需要如上面所声明**的、以void为返回类型，并且必须仅接受一个string对象作为参数；如果返回类型或参数不匹配，编译器会报错。 可以通过下面的语句来实例化Callback类的对象： Callback类的对象可以像方法一样使用： Callback类的对象可以承载多个方法，这些方法将按照添加顺序依次执行，这个特性被称为“多播”。 需要注意，如果重复向一个委托中加入相同的方法，那么这个方法也会被执行多次： 另外，匿名方法是不能直接通过lambda表达式取消订阅的，这是因为lambda表达式实际上是新创建了一个委托的实例，即使委托的内容完全一致，它们也不是一样的委托，因此无法被正常地取消订阅： 带有返回值的委托委托类型也可以在声明时指定返回类型： 但是涉及多播时，情况会有点特殊，多播委托调用时会依次执行所有订阅的方法，但只有最后一个方法的返回值会被保留并作为多播委托的返回值。 Action和Func如果开发者要为每个命名空间内的每种返回类型和参数列表的组合都声明一种委托类型的话，实在是太麻烦了。 为了简化委托类型的声明流程，C#提供了两个内置的委托类型模板类，Action&lt;&gt;和Func&lt;&gt;。 Action用于表示一个不返回值的委托，它可以有最多四个参数，如Action&lt;int&gt;表示一个带有一个整数参数的委托，而Action&lt;int, float, string, bool&gt;表示一个带有四个参数的方法，分别为整数、浮点数、字符串和布尔值。 Func类与Action类相似，它表示带有返回值的方法，并且在声明时需要指定返回值类型。例如，Func&lt;int&gt;表示一个返回整数类型的方法，而Func&lt;int, float, string, bool&gt;表示一个带有三个参数并返回布尔值类型的方法。 使用Action和Func模版类来定义自己的委托，可以精简声明的流程，也增强了委托在不同模块之间的通用性，因为使用delegate关键字声明的不同委托类型之间即使返回类型和参数列表完全一致，也无法直接类型转换。 event 事件event是一种特殊的委托，它与普通委托的核心区别在于它只能在声明它的类内调用。 如果我们在另一个类中试图触发event，编译器会报出错误： 在声明一个event时，相较于声明普通的委托对象，我们只需要在声明语句中加入关键字event即可： event相较于delegate具有更好的封装性和安全性，但相对地也失去了一些灵活性。如果确定委托只应该在类内被触发，就把它标记为event吧。"},{"title":"VSCode清理\"GIT:重新打开已关闭的储存库\"列表","date":"2025-01-03T07:35:21.000Z","url":"/2025/01/03/VSCode%E6%B8%85%E7%90%86GIT-%E9%87%8D%E6%96%B0%E6%89%93%E5%BC%80%E5%B7%B2%E5%85%B3%E9%97%AD%E7%9A%84%E5%82%A8%E5%AD%98%E5%BA%93%E5%88%97%E8%A1%A8/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["IDE","/tags/IDE/"],["VSCode","/tags/VSCode/"]],"categories":[["Unity","/categories/Unity/"]],"content":"VSCode以一个文件夹为Root创建工作区，也就是WorkSpace。 比如一个Unity项目，用VSCode打开时，就会以Unity项目文件夹为Root创建一个工作区。 有时候一个工作区内需要好几个版本管理区域，我们就会在VSCode中打开好多个版本管理库。任务完成后，我们可能会在VSCode中关闭这个储存库，或者直接删掉这个储存库。 VSCode中有一个常用命令，叫做Git：重新打开已关闭的储存库，它可以方便我们灵活地开启和切换到其他在工作中的库。然而，这个命令的列表会记录所有曾经在工作区中打开过的库，不管这个库实际上是否仍然存在。 日积月累下来列表会变得冗余难用，但是VSCode并没有提供方法去管理这个列表。 在网上搜了一圈后，我得到这样一个方法可以清理掉这个已关闭的储存库的列表： 首先找到这个路径： C:\\Users\\YourUserName\\AppData\\Roaming\\Code\\User\\workspaceStorage 里面应该有一堆以哈希值命名的文件夹。 在workspaceStorage这个文件夹中右键，用VSCode打开，然后通过侧边栏中的全局搜索功能去搜你的工作区名字： 找到这个文件所处的文件夹，直接删掉整个文件夹。 这样做其实是删掉了工作区的一些长久储存的数据，包括打开过的Git储存库的列表。 这可能会误伤到其他工作区设置，不过应该影响不是很大，只是一些IDE的配置而已。"},{"title":"C# 泛型方法","date":"2025-01-02T10:01:52.000Z","url":"/2025/01/02/C-sharp%20%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["C#","/tags/C/"]],"categories":[["Unity","/categories/Unity/"]],"content":"Unity里有很多内置的泛型方法，比如GetComponent&lt;&gt;、GetObjectOfType&lt;&gt;等。 有时候我们会希望定义自己的泛型方法，在我的情况中，我希望编写一个方法用于检查一个委托中是否已经订阅了某个方法。 如果不使用泛型方法，需要为每一种Action都重载一个方法的实现，非常麻烦。 如果像下面这样使用泛型方法的话，会非常方便： 可以观察到泛型方法ActionHasDelegate对于不同类型的Action都能够顺利判断，可喜可贺，可喜可贺。"},{"title":"在Unity C#中执行其他的程序或cmd命令行","date":"2025-01-02T09:20:57.000Z","url":"/2025/01/02/%E5%9C%A8Unity%20CSharp%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%85%B6%E4%BB%96%E7%9A%84%E7%A8%8B%E5%BA%8F%20%E6%88%96%20cmd%E5%91%BD%E4%BB%A4%E8%A1%8C/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["C#","/tags/C/"]],"categories":[["Unity","/categories/Unity/"]],"content":"如果能在Unity中直接使用一些外部工具有时会非常方便。 直接在Unity中执行Tortoise指令有时想看一个文件或文件夹的Git Log，我们需要先在Unity中右键单击文件，再在文件夹中找到这个文件，然后再右键单击文件，才能打开Git Log。如果能在Unity中右键选中文件后直接打开GitLog会方便很多。 我们可以在Unity的MenuItem的Assets菜单中添加一项来做到这件事情： 直接在Unity中使用Python脚本Python有一些好用的库，如果能在Unity中直接执行Python脚本处理指定的对象，我们就不用自己从头开始实现一些功能了。 比如我们希望加一个菜单项，上下翻转一张纹理，可以这样做： 在py文件中，我们可以通过sys.argv获取到C#中输入的参数： 可以得到这样的效果： 直接在Unity中执行bat脚本有时我们会需要在Unity中执行一些bat脚本，用于做资产的检查等操作。 但是Unity中无法直接执行bat脚本，因此也需要我们去做一步改造： 上面Arguments中的&#x2F;c指的是执行完后关掉cmd窗口，相对的还有&#x2F;k。 /c：执行指定的命令并在完成后终止。 /k：执行指定的命令但在完成后不终止命令提示符窗口。 可以做到这样的效果： "},{"title":"浅谈Unity中的级联阴影渲染","date":"2024-12-16T10:05:18.000Z","url":"/2024/12/16/%E6%B5%85%E8%B0%88Unity%E4%B8%AD%E7%9A%84%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1%E6%B8%B2%E6%9F%93/","tags":[["长篇","/tags/%E9%95%BF%E7%AF%87/"],["渲染","/tags/%E6%B8%B2%E6%9F%93/"]],"categories":[["Unity","/categories/Unity/"]],"content":"Unity URP中的阴影方案是**“SSSM（Screen Space Shadow Mapping，屏幕空间阴影映射）”**，本文将对Unity中的默认阴影方案做简单的解读。 光源有光源才能投出阴影，光源上也有一些阴影相关的配置。 以主平行光为例，通过FrameDebuger观察到调整其阴影配置时传入GPU的_MainLightShadowParams发生变化。 从URPLitShader中观察到_MainLightShadowParams控制了这些表现： 级联阴影在Unity的渲染管线资产中，可以配置主光源的级联阴影参数。 级联阴影是以牺牲远处阴影质量为代价、提升近处阴影质量的一种技术。 级联数量为4意味着ShadowMap将被等分为4个象限，彩色的条带代表了最大距离内四个象限如何分配阴影图的空间。 如紫色块0上的信息，意味着距离相机0~6.2米的渲染点将会使用第0象限的阴影图，第0象限储存了6.2米内的场景的深度信息，绿色块1则意味着相机6.2~14.6米的渲染点将使用第1象限的阴影图，第1象限储存了8.5米的有效信息。下图为4级联的示意阴影图： 级联阴影的做法有点类似于图像的伽马编码，将更多的精度用于存储人眼比较敏感的暗部信息。 Shadow Map的生成物体被渲染时，会比较灯光坐标系下渲染点深度和ShadowMap中记录的最小深度，如果渲染点的深度大于最小深度，说明渲染点处于阴影中；如果使用了PCSS等滤波软阴影方案，则会多次采样ShadowMap，得到一个0~1的值用于描述渲染点被阴影遮蔽的程度。最终，用Shadow值去影响输出颜色，就让一个物体接受了阴影。 那么这张ShadowMap是如何生成的呢？ 以主平行光为例，可以从FrameDebuger中观察到在渲染管线流程的靠前部分渲染了主光源的Shadow Map。这里暂时没有考虑级联阴影。 为什么这张Shadow Map长这样？它是怎么被渲染出来的？ 与正常渲染一个物体的流程类似地，Shadow Map也是通过流水线进行渲染的。首先管线会创建一个特定的相机，然后调用场景里所有投影物体的Shader的ShadowCaster这个Pass，Pass本身不输出颜色。待所有的物体的ShadowCaster执行完毕后，将当前的深度缓冲输出到作为RenderTarget的ShadowMap即可。 如果有多个光源，每个光源都会以上述的流程渲染自己的ShadowMap。 上面所谓的特定的相机是如何确定的呢？ 笔者在灯光GameObject下添加一个相机，尝试复刻出ShadowMap来。 首先来确定相机的Transform。相机的朝向就是光源的朝向，位置则是主相机前方最大阴影距离处；这个最大阴影距离通过渲染管线资产进行配置。 然后配置相机上的参数。根据平行光的特性，需要将相机的投影类型改为正交投影；然后将相机的视野大小也改为最大阴影距离，同时为了避免场景被远近裁剪平面裁剪，需要配置一个合适的裁剪平面距离。 设置完成后，就能从这个新的相机中观察到与主相机ShadowMap一模一样的轮廓，主平行光渲染ShadowMap的相机就是使用类似这样的方法确定的。 级联ShadowMap级联ShadowMap相对于上面单张ShadowMap的渲染流程稍有差异。 首先DrawCall的次数将会变成级联数，每个级联的ShadowMap会渲染到最终输出ShadowMap对应的象限中。 其次每个级联相机的位置和视野大小也是不同的，需要根据级联的分割参数做出对应的调整。 阴影的渲染得到ShadowMap后，在渲染物体时就可以比较渲染点在灯光坐标系下的深度和ShadowMap中记录的深度，以此来判断渲染点是否在阴影的遮蔽中。 Unity软阴影的实现是对ShadowMap以一个固定大小的滤波核进行滤波，滤波结果就是被阴影遮蔽的程度。 下列代码块是高质量设置下软阴影的代码，共采样ShadowMap16次： 与PCSS不同的是，Unity的SSSM没有根据渲染点离遮蔽物的距离去动态调整滤波核的Step步长，因此SSSM无法做到PCSS那样真实的近实远虚的软阴影，只能让阴影的边缘不那么锐利。 拿到遮蔽程度后，Unity URP LIt Shader将其乘到光源的衰减系数里面，影响最终输出的颜色： 如此这般，物体上就渲染出了阴影。"},{"title":"关于Material Property Block","date":"2024-11-25T16:04:30.000Z","url":"/2024/11/26/%E5%85%B3%E4%BA%8EMPB%E2%80%94%E2%80%94Material%20Property%20Block/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["渲染","/tags/%E6%B8%B2%E6%9F%93/"]],"categories":[["Unity","/categories/Unity/"]],"content":"Material Property Block（材质属性块）是Unity中的一个数据结构，用于在渲染过程中向材质实例提供额外的属性数据。它可以包含一组键值对，每个键值对对应于材质实例中的一个属性。在渲染时，可以将多个对象的MPB实例传递给渲染器，以避免为每个对象创建新的材质数据副本，从而提高渲染性能。同时，使用MPB还可以更容易地实现材质属性的动态变化，因为它可以在渲染过程中动态修改材质属性。 用法和Material类似地、可以直接使用Block对象的SetFloat等方法。 Block对象可以直接从Renderer组件里获取，改完后再塞回去。 当使用上述的方法给Renderer Set过属性后，对应的属性将无法再通过材质面板被直接修改。这样的修改在运行时是持续性的，即只需要Set一次，这个值将在下次修改block之前都保持在你Set的值。因此只在确认需要更新属性的时候SetBlock即可，这个Get和SetBlock的操作是有一定性能开销的。 如果想要恢复参数为材质上本身的，可以对Renderer使用：Renderer.SetPropertyBlock(null); Material Property Block在GPUInstance中也有非常广泛的应用。 优缺点优点 可以避免生成很多材质实例，材质实例还是太多了还是蛮占内存的，尤其是属性比较多的材质。 关于材质示例 缺点 经过验证、不同的MPB会导致合批被打断。 "},{"title":"Hello World","date":"2024-11-13T13:00:34.000Z","url":"/2024/11/13/hello-world/","tags":[["短篇","/tags/%E7%9F%AD%E7%AF%87/"],["长篇","/tags/%E9%95%BF%E7%AF%87/"]],"categories":[["Unity","/categories/Unity/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]